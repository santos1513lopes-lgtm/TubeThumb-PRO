<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TubeThumb PRO - v7.3.1 (Multi-Text Fixed)</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ñ∂Ô∏è</text></svg>">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Bangers&family=Montserrat:wght@700;900&family=Oswald:wght@500;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { background-color: #0f172a; color: #f3f4f6; font-family: 'Montserrat', sans-serif; overflow-x: hidden; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        .canvas-container {
            background-image: linear-gradient(45deg, #1e293b 25%, transparent 25%), linear-gradient(-45deg, #1e293b 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #1e293b 75%), linear-gradient(-45deg, transparent 75%, #1e293b 75%);
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .toggle-checkbox:checked { right: 0; border-color: #22c55e; }
        .toggle-checkbox:checked + .toggle-label { background-color: #22c55e; }
    </style>
</head>
<body class="selection:bg-red-500/30 pb-20">

    <header class="border-b border-gray-800 bg-gray-900/95 backdrop-blur-md sticky top-0 z-50 shadow-lg">
        <div class="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="bg-gradient-to-br from-red-600 to-orange-600 p-2 rounded-xl shadow-lg shadow-red-500/20 transform hover:scale-105 transition-transform">
                    <svg class="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                </div>
                <div><h1 class="text-2xl font-black tracking-tighter italic text-white leading-none">TubeThumb</h1><span class="text-[10px] font-bold text-red-500 tracking-widest uppercase">PRO v7.3 Multi-Text</span></div>
            </div>
            <div class="flex gap-2">
                <div id="saveIndicator" class="hidden md:flex items-center text-[10px] text-gray-500 font-bold uppercase tracking-wider mr-2"><span class="w-2 h-2 bg-green-500 rounded-full mr-2 animate-pulse"></span> Auto-Saved</div>
                <button id="btnResetApp" class="flex items-center gap-2 bg-gray-800 hover:bg-gray-700 text-gray-300 px-4 py-2 rounded-full text-xs font-bold transition-all border border-gray-700 hover:border-gray-500">Reset</button>
                <button id="btnMagicRemix" class="flex items-center gap-2 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white px-5 py-2 rounded-full text-xs font-bold transition-all shadow-lg border border-white/10">Magic Remix</button>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-8 grid grid-cols-1 lg:grid-cols-12 gap-8">
        <div class="lg:col-span-4 space-y-4 h-full">
            
            <div class="bg-gray-800/50 p-5 rounded-2xl border border-gray-700/50 hover:border-gray-600 transition-colors">
                <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-4 flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-blue-500"></span> Source & Adjustments</h2>
                <label class="group relative flex flex-col items-center justify-center w-full h-24 border-2 border-dashed border-gray-700 rounded-xl cursor-pointer hover:bg-gray-800 hover:border-blue-500 transition-all overflow-hidden bg-gray-900/50 mb-5">
                    <img id="previewThumb" class="absolute inset-0 w-full h-full object-cover opacity-40 group-hover:opacity-20 transition-opacity hidden" />
                    <div class="flex flex-col items-center justify-center z-10 text-gray-400 group-hover:text-blue-400 transition-colors"><span class="text-xs font-bold" id="uploadText">Click to Upload Image</span></div>
                    <input type="file" id="imageInput" class="hidden" accept="image/*" />
                </label>
                <div class="grid grid-cols-3 gap-4">
                    <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Brightness</label><input type="range" id="filterBrightness" min="50" max="150" value="100" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-blue-500"></div>
                    <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Contrast</label><input type="range" id="filterContrast" min="50" max="150" value="100" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-blue-500"></div>
                    <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Saturation</label><input type="range" id="filterSaturate" min="0" max="200" value="100" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-blue-500"></div>
                </div>
                <div class="mt-4 pt-3 border-t border-gray-700 space-y-1">
                    <div class="flex justify-between"><label class="text-[9px] font-bold text-gray-500 uppercase">Image Zoom</label><button onclick="resetImageTransform()" class="text-[9px] text-blue-400 hover:text-white">Reset Position</button></div>
                    <input type="range" id="imageZoom" min="0.1" max="3" step="0.1" value="1" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-blue-400">
                </div>
            </div>

            <div class="bg-gray-800/50 p-5 rounded-2xl border border-gray-700/50 hover:border-gray-600 transition-colors">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-yellow-500"></span> Text Layers</h2>
                    <button id="btnAddText" class="text-xs bg-yellow-500 text-black font-bold px-3 py-1 rounded-full hover:bg-yellow-400 transition-colors">+ Add New Text</button>
                </div>
                
                <div id="textControlsArea">
                    <div class="mb-4">
                        <div class="flex justify-between text-[10px] text-gray-500 uppercase font-bold mb-1">
                            <span>Content</span>
                            <button id="btnDeleteText" class="text-red-500 hover:text-white">Delete Layer</button>
                        </div>
                        <textarea id="textContent" class="w-full h-20 bg-gray-900 border-2 border-gray-700 rounded-xl px-4 py-3 text-lg font-black text-white focus:border-yellow-500 focus:outline-none resize-none placeholder-gray-600 transition-colors"></textarea>
                    </div>

                    <div class="space-y-4">
                        <div class="grid grid-cols-2 gap-2" id="fontButtons"></div>
                        
                        <div class="bg-gray-900 rounded-xl p-3 border border-gray-700">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-xs text-gray-400 font-bold">Gradient?</span>
                                <div class="relative inline-block w-8 mr-2 align-middle select-none transition duration-200 ease-in"><input type="checkbox" name="toggle" id="gradientToggle" class="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-4 appearance-none cursor-pointer border-gray-600"/><label for="gradientToggle" class="toggle-label block overflow-hidden h-4 rounded-full bg-gray-700 cursor-pointer"></label></div>
                            </div>
                            <div id="solidColorControls" class="flex gap-2 items-center">
                                <div class="flex gap-1 flex-1 justify-end" id="colorButtons"></div>
                                <input type="color" id="colorPicker" class="w-6 h-6 rounded-full bg-transparent border-0 p-0 cursor-pointer hover:scale-110 transition-transform">
                            </div>
                            <div id="gradientControls" class="hidden space-y-2 mt-2 pt-2 border-t border-gray-800">
                                <div class="flex justify-between items-center"><span class="text-[10px] text-gray-500 uppercase">Start</span><input type="color" id="gradStartColor" class="w-6 h-6 rounded-full bg-transparent border-0 p-0 cursor-pointer"></div>
                                <div class="flex justify-between items-center"><span class="text-[10px] text-gray-500 uppercase">End</span><input type="color" id="gradEndColor" class="w-6 h-6 rounded-full bg-transparent border-0 p-0 cursor-pointer"></div>
                            </div>
                        </div>

                        <div class="grid grid-cols-2 gap-4">
                            <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Size</label><input type="range" id="fontSize" min="40" max="350" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-white"/></div>
                            <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Stroke</label><input type="range" id="strokeWidth" min="0" max="40" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-red-500"/></div>
                        </div>
                        
                        <div class="pt-4 border-t border-gray-700 space-y-3">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-[10px] font-bold text-purple-400 uppercase flex items-center gap-1">Shadow</span>
                                <div class="relative inline-block w-8 mr-2 align-middle select-none transition duration-200 ease-in"><input type="checkbox" name="toggle" id="shadowToggle" class="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-4 appearance-none cursor-pointer border-gray-600"/><label for="shadowToggle" class="toggle-label block overflow-hidden h-4 rounded-full bg-gray-700 cursor-pointer"></label></div>
                            </div>
                            <div class="bg-gray-900 rounded-xl p-3 border border-gray-700 flex justify-between items-center mb-2">
                                <span class="text-xs text-gray-400 font-bold">FX Color</span><input type="color" id="shadowColorPicker" class="w-8 h-8 rounded-full bg-transparent border-0 p-0 cursor-pointer hover:scale-110 transition-transform">
                            </div>
                            <div class="grid grid-cols-2 gap-4">
                                <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Blur</label><input type="range" id="shadowBlur" min="0" max="100" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-purple-500"/></div>
                                <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Distance</label><input type="range" id="shadowDistance" min="0" max="50" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-purple-500"/></div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2 aspect-[3/1.5]" id="layoutGrid"></div>
                    </div>
                </div>
            </div>

            <div class="bg-gray-800/50 p-5 rounded-2xl border border-gray-700/50 hover:border-gray-600 transition-colors">
                <div class="flex justify-between items-center mb-4">
                     <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-orange-500"></span> Border Style</h2>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in"><input type="checkbox" name="toggle" id="borderToggle" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-gray-600"/><label for="borderToggle" class="toggle-label block overflow-hidden h-5 rounded-full bg-gray-700 cursor-pointer"></label></div>
                </div>
                <div class="space-y-4">
                    <div class="grid grid-cols-4 gap-2">
                        <button onclick="setBorderType('solid')" id="btnBorderSolid" class="py-2 rounded border border-gray-600 text-gray-400 hover:text-white hover:bg-gray-700 flex justify-center" title="Solid Box"><div class="w-4 h-4 border-2 border-current"></div></button>
                        <button onclick="setBorderType('rounded')" id="btnBorderRounded" class="py-2 rounded border border-gray-600 text-gray-400 hover:text-white hover:bg-gray-700 flex justify-center" title="Rounded"><div class="w-4 h-4 border-2 border-current rounded-md"></div></button>
                        <button onclick="setBorderType('corners')" id="btnBorderCorners" class="py-2 rounded border border-gray-600 text-gray-400 hover:text-white hover:bg-gray-700 flex justify-center" title="Corners Only"><svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M4 8V4h4 M20 8V4h-4 M4 16v4h4 M20 16v4h-4"/></svg></button>
                        <button onclick="setBorderType('brackets')" id="btnBorderBrackets" class="py-2 rounded border border-gray-600 text-gray-400 hover:text-white hover:bg-gray-700 flex justify-center" title="Brackets"><svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M8 4H4v16h4 M16 4h4v16h-4"/></svg></button>
                    </div>
                    <div class="bg-gray-900 rounded-xl p-3 border border-gray-700 flex justify-between items-center"><span class="text-xs text-gray-400 font-bold">Border Color</span><input type="color" id="borderColorPicker" value="#FFFF00" class="w-8 h-8 rounded-full bg-transparent border-0 p-0 cursor-pointer hover:scale-110 transition-transform"></div>
                    <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Thickness</label><input type="range" id="borderThickness" min="5" max="50" value="20" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-orange-500"/></div>
                </div>
            </div>

            <div class="bg-gray-800/50 p-5 rounded-2xl border border-gray-700/50 hover:border-gray-600 transition-colors">
                 <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-4 flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-red-500"></span> Stickers & Assets</h2>
                <div class="space-y-5">
                    <div><div class="flex gap-2 overflow-x-auto pb-2 scrollbar-hide" id="shapeButtons"></div></div>
                    <div><div class="grid grid-cols-6 gap-2" id="emojiButtons"></div></div>
                    <div id="stickerControls" class="pt-4 border-t border-gray-700 hidden animate-fade-in">
                        <div class="flex justify-between items-center mb-3">
                             <span class="text-[10px] font-bold text-blue-400 uppercase flex items-center gap-1">Edit Selected Sticker</span>
                             <div class="flex gap-2"><button id="btnFlipSticker" class="bg-gray-700 hover:bg-gray-600 text-white text-[10px] px-3 py-1 rounded-full font-bold transition-colors">FLIP ‚Üî</button><button id="btnDeleteSticker" class="bg-red-500/10 hover:bg-red-500 text-red-500 hover:text-white p-1 rounded-full transition-colors"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg></button></div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Scale</label><input type="range" id="stickerScale" min="0.2" max="3" step="0.1" value="1" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-blue-500"></div>
                            <div class="space-y-1"><label class="text-[9px] font-bold text-gray-500 uppercase">Rotate</label><input type="range" id="stickerRotation" min="-180" max="180" value="0" class="w-full h-1 bg-gray-700 rounded-full appearance-none cursor-pointer accent-blue-500"></div>
                        </div>
                    </div>
                    <div id="noStickerSelected" class="text-xs text-gray-600 font-medium text-center py-2 border-t border-gray-800">Select an item to edit</div>
                </div>
            </div>
        </div>

        <div class="lg:col-span-8">
            <div class="sticky top-28 space-y-6">
                <div class="flex justify-between items-center mb-2">
                    <button id="btnSafeZone" class="text-[10px] px-2 py-0.5 rounded border border-gray-600 text-gray-400 hover:text-white transition-colors">Toggle Safe Zone</button>
                </div>
                <div class="relative w-full aspect-video rounded-2xl overflow-hidden shadow-2xl border-2 border-gray-700 bg-gray-900 canvas-container group">
                    <canvas id="mainCanvas" class="w-full h-full object-contain cursor-crosshair touch-none"></canvas>
                    <div class="absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity bg-black/70 backdrop-blur px-3 py-1.5 rounded-lg text-xs font-medium text-white pointer-events-none border border-white/10">Scroll: Zoom BG | Click Text to Edit</div>
                </div>
                <div class="flex flex-col items-center gap-3">
                    <button id="btnDownload" class="flex items-center gap-3 px-10 py-4 rounded-full font-black text-xl tracking-wide transition-all transform hover:scale-105 hover:-translate-y-1 bg-gradient-to-r from-red-600 to-orange-600 text-white shadow-xl shadow-red-900/30 cursor-not-allowed grayscale opacity-50" disabled>DOWNLOAD THUMBNAIL</button>
                    <div id="downloadStatus" class="flex items-center gap-2 text-green-400 text-sm font-bold opacity-0 transition-opacity"><span id="statusText">Image saved successfully!</span></div>
                </div>
            </div>
        </div>
    </main>

<script>
    const FONTS = [{ name: 'Impact', value: 'Anton' }, { name: 'Bold', value: 'Montserrat' }, { name: 'Modern', value: 'Oswald' }, { name: 'Comic', value: 'Bangers' }];
    const COLORS = ['#FFFFFF', '#FFFF00', '#FF0000', '#00FF00', '#00FFFF', '#FF00FF'];
    const EMOJIS = ['üò±', 'ü§î', 'üî•', 'üí∞', 'üöÄ', '‚ö†Ô∏è', '‚úÖ', '‚ùå', 'ü§°', 'üò≠', 'ü§Ø', 'üíé'];
    const SHAPE_BUTTONS = [
        { name: 'Curved', src: `data:image/svg+xml;utf8,<svg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'><path d='M20,150 Q50,50 150,50 L130,20 L180,50 L130,80 L150,50' fill='red' stroke='white' stroke-width='8' stroke-linejoin='round' /></svg>` },
        { name: 'Straight', src: `data:image/svg+xml;utf8,<svg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'><path d='M20,100 L120,100 L120,70 L180,110 L120,150 L120,120 L20,120 Z' fill='red' stroke='white' stroke-width='8' stroke-linejoin='round' /></svg>` },
        { name: 'Pointer', src: `data:image/svg+xml;utf8,<svg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'><path d='M80,180 L80,100 L50,130 L100,20 L150,130 L120,100 L120,180 Z' fill='red' stroke='white' stroke-width='8' stroke-linejoin='round' /></svg>` },
        { name: 'Circle', src: `data:image/svg+xml;utf8,<svg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'><circle cx='100' cy='100' r='80' fill='none' stroke='red' stroke-width='12' stroke-dasharray='20,10' /></svg>` },
        { name: 'Square', src: `data:image/svg+xml;utf8,<svg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'><rect x='20' y='20' width='160' height='160' fill='none' stroke='red' stroke-width='12' stroke-linejoin='round' /></svg>` },
        { name: 'Live', src: `data:image/svg+xml;utf8,<svg viewBox='0 0 200 100' xmlns='http://www.w3.org/2000/svg'><rect x='10' y='10' width='180' height='80' rx='10' fill='red' /><text x='100' y='65' font-family='Arial' font-weight='bold' font-size='50' fill='white' text-anchor='middle'>LIVE</text></svg>` }
    ];

    // --- STATE MANAGEMENT ---
    const createTextObject = (id, content, yPos) => ({
        id: id, content: content, x: 640, y: yPos,
        color: "#FFFFFF", fontFamily: "Anton", fontSize: 140, strokeWidth: 15,
        gradient: { enabled: false, start: "#FFFF00", end: "#FF0000" },
        shadow: { enabled: true, color: "#000000", blur: 20, distance: 15 }
    });

    const state = {
        image: null, bgTransform: { x: 0, y: 0, scale: 1 }, isDraggingBg: false,
        texts: [ createTextObject(1, "WATCH", 250), createTextObject(2, "THIS!", 450) ],
        activeTextId: 1, 
        isDraggingText: false, dragTextId: null,
        showSafeZone: true,
        border: { enabled: false, color: "#FFFF00", width: 20, type: 'solid' },
        stickers: [], selectedStickerId: null, isDragging: false, dragOffset: { x: 0, y: 0 },
        filters: { brightness: 100, contrast: 100, saturate: 100 }
    };

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const btnDownload = document.getElementById('btnDownload');
    const stickerControls = document.getElementById('stickerControls');
    const noStickerSelected = document.getElementById('noStickerSelected');

    function init() { loadFromLocal(); renderUI(); setupEventListeners(); resizeCanvas(); drawCanvas(); }

    function saveToLocal() {
        const stateToSave = { ...state }; stateToSave.image = null; 
        stateToSave.isDragging = false; stateToSave.isDraggingText = false; stateToSave.isDraggingBg = false;
        localStorage.setItem('tubethumb_v73_settings', JSON.stringify(stateToSave));
    }

    function loadFromLocal() {
        const saved = localStorage.getItem('tubethumb_v73_settings');
        if (saved) { 
            try { 
                const parsed = JSON.parse(saved); Object.assign(state, parsed); state.image = null; 
            } catch(e) { console.error("Could not load save", e); } 
        }
    }

    const getActiveText = () => state.texts.find(t => t.id === state.activeTextId) || state.texts[0];

    function renderUI() {
        const activeText = getActiveText();
        document.getElementById('textContent').value = activeText.content;
        document.getElementById('fontButtons').innerHTML = FONTS.map(font => `<button onclick="updateActiveText('fontFamily', '${font.value}')" class="text-xs py-2 px-1 rounded-lg border transition-all ${activeText.fontFamily === font.value ? 'bg-white text-black border-white font-bold shadow-sm' : 'bg-gray-800 text-gray-400 border-gray-700 hover:border-gray-500'}" style="font-family: ${font.value}">${font.name}</button>`).join('');
        document.getElementById('colorButtons').innerHTML = COLORS.map(color => `<button onclick="updateActiveText('color', '${color}')" class="w-6 h-6 rounded-full border-2 ${activeText.color === color ? 'border-white scale-125 shadow-md' : 'border-transparent'} transition-transform" style="background-color: ${color}"></button>`).join('');
        document.getElementById('layoutGrid').innerHTML = [
            {id:'top-left', x:0.1, y:0.15}, {id:'top-center', x:0.5, y:0.15}, {id:'top-right', x:0.9, y:0.15},
            {id:'mid-left', x:0.1, y:0.5}, {id:'center', x:0.5, y:0.5}, {id:'mid-right', x:0.9, y:0.5},
            {id:'bottom-left', x:0.1, y:0.85}, {id:'bottom-center', x:0.5, y:0.85}, {id:'bottom-right', x:0.9, y:0.85}
        ].map(pos => `<button onclick="setPresetPosition(${pos.x}, ${pos.y})" class="rounded hover:bg-gray-700 transition-colors border bg-gray-800/50 border-gray-700 flex items-center justify-center"><div class="w-1.5 h-1.5 rounded-full bg-gray-600"></div></button>`).join('');

        document.getElementById('colorPicker').value = activeText.color;
        document.getElementById('fontSize').value = activeText.fontSize;
        document.getElementById('strokeWidth').value = activeText.strokeWidth;
        document.getElementById('gradientToggle').checked = activeText.gradient.enabled;
        document.getElementById('gradStartColor').value = activeText.gradient.start;
        document.getElementById('gradEndColor').value = activeText.gradient.end;
        if(activeText.gradient.enabled) {
            document.getElementById('gradientControls').classList.remove('hidden');
            document.getElementById('solidColorControls').classList.add('opacity-50', 'pointer-events-none');
        } else {
            document.getElementById('gradientControls').classList.add('hidden');
            document.getElementById('solidColorControls').classList.remove('opacity-50', 'pointer-events-none');
        }
        document.getElementById('shadowToggle').checked = activeText.shadow.enabled;
        document.getElementById('shadowColorPicker').value = activeText.shadow.color;
        document.getElementById('shadowBlur').value = activeText.shadow.blur;
        document.getElementById('shadowDistance').value = activeText.shadow.distance;

        document.getElementById('shapeButtons').innerHTML = SHAPE_BUTTONS.map((shape, idx) => `<button onclick="addShape(${idx})" class="w-12 h-12 bg-gray-800 rounded-xl hover:bg-gray-700 border border-gray-700 flex-shrink-0 flex items-center justify-center p-2 group transition-all hover:scale-105"><img src="${shape.src}" class="w-full h-full object-contain"></button>`).join('');
        document.getElementById('emojiButtons').innerHTML = EMOJIS.map(emoji => `<button onclick="addSticker('emoji', '${emoji}')" class="text-2xl hover:bg-gray-800 rounded-lg p-1 transition-transform hover:scale-125">${emoji}</button>`).join('');
        
        document.getElementById('borderToggle').checked = state.border.enabled;
        document.getElementById('borderColorPicker').value = state.border.color;
        document.getElementById('borderThickness').value = state.border.width;
        const styles = ['solid', 'rounded', 'corners', 'brackets'];
        styles.forEach(s => {
            const btn = document.getElementById(`btnBorder${s.charAt(0).toUpperCase() + s.slice(1)}`);
            if(state.border.type === s) { btn.classList.add('bg-gray-700', 'text-white', 'border-white/50'); btn.classList.remove('text-gray-400'); } 
            else { btn.classList.remove('bg-gray-700', 'text-white', 'border-white/50'); btn.classList.add('text-gray-400'); }
        });

        document.getElementById('imageZoom').value = state.bgTransform.scale;
        
        if (state.selectedStickerId) { stickerControls.classList.remove('hidden'); noStickerSelected.classList.add('hidden'); const sticker = state.stickers.find(s => s.id === state.selectedStickerId); if (sticker) { document.getElementById('stickerScale').value = sticker.scale; document.getElementById('stickerRotation').value = sticker.rotation; } } 
        else { stickerControls.classList.add('hidden'); noStickerSelected.classList.remove('hidden'); }

        const btnSafe = document.getElementById('btnSafeZone');
        btnSafe.className = `text-[10px] px-2 py-0.5 rounded border transition-colors ${state.showSafeZone ? 'bg-green-500/10 text-green-400 border-green-500/50' : 'border-gray-600 text-gray-400'}`;

        if (state.image) { btnDownload.disabled = false; btnDownload.classList.remove('grayscale', 'opacity-50', 'cursor-not-allowed'); document.getElementById('uploadText').innerText = "Click to Change Image"; } 
        else { btnDownload.disabled = true; btnDownload.classList.add('grayscale', 'opacity-50', 'cursor-not-allowed'); }

        document.getElementById('filterBrightness').value = state.filters.brightness;
        document.getElementById('filterContrast').value = state.filters.contrast;
        document.getElementById('filterSaturate').value = state.filters.saturate;
    }

    function resizeCanvas() { canvas.width = 1280; canvas.height = 720; }
    function getTextMetrics(text, font, size) { ctx.save(); ctx.font = `900 ${size}px "${font}", sans-serif`; const lines = text.split('\n'); let width = 0; lines.forEach(line => { const w = ctx.measureText(line.toUpperCase()).width; if (w > width) width = w; }); const lineHeight = size * 1.1; const height = lines.length * lineHeight; ctx.restore(); return { width, height, lineHeight }; }

    function drawCanvas() {
        const width = canvas.width; const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        if (state.image) {
            ctx.save();
            const scale = Math.max(width / state.image.width, height / state.image.height) * state.bgTransform.scale;
            const x = (width / 2) - (state.image.width / 2) * scale + state.bgTransform.x;
            const y = (height / 2) - (state.image.height / 2) * scale + state.bgTransform.y;
            ctx.filter = `brightness(${state.filters.brightness}%) contrast(${state.filters.contrast}%) saturate(${state.filters.saturate}%)`;
            ctx.drawImage(state.image, x, y, state.image.width * scale, state.image.height * scale);
            ctx.filter = 'none'; ctx.restore();
        } else {
            ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, width, height); ctx.fillStyle = '#1e293b'; ctx.beginPath(); ctx.arc(width/2, height/2, 100, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#475569'; ctx.font = 'bold 30px Montserrat'; ctx.textAlign = 'center'; ctx.fillText('Upload an Image to Start', width / 2, height / 2);
        }

        state.stickers.forEach(sticker => {
            ctx.save(); ctx.translate(sticker.x, sticker.y); ctx.rotate((sticker.rotation * Math.PI) / 180); ctx.scale(sticker.scaleX, 1); ctx.scale(sticker.scale, sticker.scale); ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 15; ctx.shadowOffsetX = 5; ctx.shadowOffsetY = 5;
            if (sticker.type === 'emoji') { ctx.font = '100px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(sticker.content, 0, 0); } 
            else { const img = new Image(); img.src = sticker.content; ctx.drawImage(img, -100, -100, 200, 200); }
            ctx.restore();
            if (sticker.id === state.selectedStickerId) { ctx.save(); ctx.translate(sticker.x, sticker.y); ctx.rotate((sticker.rotation * Math.PI) / 180); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 4; ctx.setLineDash([10, 5]); const boxSize = sticker.type === 'emoji' ? 120 * sticker.scale : 220 * sticker.scale; ctx.strokeRect(-boxSize/2, -boxSize/2, boxSize, boxSize); ctx.restore(); }
        });

        state.texts.forEach(textObj => {
            ctx.save(); ctx.font = `900 ${textObj.fontSize}px "${textObj.fontFamily}", sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const lines = textObj.content.split('\n'); const lineHeight = parseInt(textObj.fontSize) * 1.1; const startY = textObj.y - ((lines.length - 1) * lineHeight) / 2;
            
            if(textObj.shadow.enabled) {
                ctx.shadowColor = textObj.shadow.color; ctx.shadowBlur = textObj.shadow.blur;
                const dist = textObj.shadow.distance; ctx.shadowOffsetX = dist * 0.7; ctx.shadowOffsetY = dist * 0.7;
            } else { ctx.shadowColor = 'transparent'; }

            lines.forEach((line, index) => {
                const lineY = startY + (index * lineHeight);
                if (textObj.strokeWidth > 0) { ctx.strokeStyle = 'black'; ctx.lineWidth = textObj.strokeWidth; ctx.lineJoin = 'round'; ctx.strokeText(line.toUpperCase(), textObj.x, lineY); }
                if (textObj.gradient.enabled) {
                    const gradient = ctx.createLinearGradient(0, lineY - parseInt(textObj.fontSize)/2, 0, lineY + parseInt(textObj.fontSize)/2);
                    gradient.addColorStop(0, textObj.gradient.start); gradient.addColorStop(1, textObj.gradient.end);
                    ctx.fillStyle = gradient;
                } else { ctx.fillStyle = textObj.color; }
                ctx.fillText(line.toUpperCase(), textObj.x, lineY);
            });
            ctx.restore();

            if(textObj.id === state.activeTextId) {
                const metrics = getTextMetrics(textObj.content, textObj.fontFamily, textObj.fontSize);
                const halfW = metrics.width / 2 + 20; const halfH = metrics.height / 2 + 20;
                ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                ctx.strokeRect(textObj.x - halfW, textObj.y - halfH, halfW*2, halfH*2);
                ctx.restore();
            }
        });

        if (state.border.enabled) {
            ctx.save(); ctx.strokeStyle = state.border.color; ctx.lineWidth = state.border.width; ctx.lineCap = 'butt'; const inset = state.border.width / 2;
            if (state.border.type === 'solid') { ctx.strokeRect(inset, inset, width - state.border.width, height - state.border.width); } 
            else if (state.border.type === 'rounded') { const r = 40; ctx.beginPath(); ctx.moveTo(inset + r, inset); ctx.lineTo(width - inset - r, inset); ctx.quadraticCurveTo(width - inset, inset, width - inset, inset + r); ctx.lineTo(width - inset, height - inset - r); ctx.quadraticCurveTo(width - inset, height - inset, width - inset - r, height - inset); ctx.lineTo(inset + r, height - inset); ctx.quadraticCurveTo(inset, height - inset, inset, height - inset - r); ctx.lineTo(inset, inset + r); ctx.quadraticCurveTo(inset, inset, inset + r, inset); ctx.stroke(); }
            else if (state.border.type === 'corners') { const cornerLen = 150; ctx.beginPath(); ctx.moveTo(inset, inset + cornerLen); ctx.lineTo(inset, inset); ctx.lineTo(inset + cornerLen, inset); ctx.moveTo(width - inset - cornerLen, inset); ctx.lineTo(width - inset, inset); ctx.lineTo(width - inset, inset + cornerLen); ctx.moveTo(width - inset, height - inset - cornerLen); ctx.lineTo(width - inset, height - inset); ctx.lineTo(width - inset - cornerLen, height - inset); ctx.moveTo(inset + cornerLen, height - inset); ctx.lineTo(inset, height - inset); ctx.lineTo(inset, height - inset - cornerLen); ctx.stroke(); }
            else if (state.border.type === 'brackets') { const bLen = 100; ctx.beginPath(); ctx.moveTo(inset + bLen, inset); ctx.lineTo(inset, inset); ctx.lineTo(inset, height - inset); ctx.lineTo(inset + bLen, height - inset); ctx.moveTo(width - inset - bLen, inset); ctx.lineTo(width - inset, inset); ctx.lineTo(width - inset, height - inset); ctx.lineTo(width - inset - bLen, height - inset); ctx.stroke(); }
            ctx.restore();
        }
        if (state.showSafeZone) { ctx.save(); ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; const safeW = 180; const safeH = 60; ctx.fillRect(width - safeW - 20, height - safeH - 20, safeW, safeH); ctx.fillStyle = 'white'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText('TIMESTAMP', width - (safeW/2) - 20, height - (safeH/2) - 15); ctx.restore(); }
        saveToLocal();
    }

    // --- RE-INSERTED MISSING FUNCTION ---
    function resetApp() { 
        if(confirm("Reset all settings?")) { 
            state.image = null;
            state.bgTransform = { x: 0, y: 0, scale: 1 };
            state.isDraggingBg = false;
            // Reset to default two text layers
            state.texts = [ createTextObject(1, "WATCH", 250), createTextObject(2, "THIS!", 450) ];
            state.activeTextId = 1;
            state.isDraggingText = false;
            state.showSafeZone = true;
            state.border = { enabled: false, color: "#FFFF00", width: 20, type: 'solid' };
            state.stickers = [];
            state.selectedStickerId = null;
            state.filters = { brightness: 100, contrast: 100, saturate: 100 };
            
            localStorage.removeItem('tubethumb_v73_settings'); 
            renderUI(); 
            drawCanvas(); 
        } 
    }
    // ------------------------------------

    window.updateActiveText = (prop, value) => {
        const text = state.texts.find(t => t.id === state.activeTextId);
        if(text) { text[prop] = value; renderUI(); drawCanvas(); }
    };
    window.setPresetPosition = (relX, relY) => {
        const text = state.texts.find(t => t.id === state.activeTextId);
        if(text) { text.x = canvas.width * relX; text.y = canvas.height * relY; renderUI(); drawCanvas(); }
    };
    window.addShape = (idx) => { addSticker('shape', SHAPE_BUTTONS[idx].src); };
    window.addSticker = (type, content) => { const newSticker = { id: Date.now().toString(), type, content, x: 640, y: 360, scale: 1, scaleX: 1, rotation: 0 }; state.stickers.push(newSticker); state.selectedStickerId = newSticker.id; renderUI(); drawCanvas(); };
    window.resetImageTransform = () => { state.bgTransform = { x: 0, y: 0, scale: 1 }; renderUI(); drawCanvas(); };
    window.setBorderType = (type) => { state.border.type = type; renderUI(); drawCanvas(); };

    function setupEventListeners() {
        document.getElementById('imageInput').addEventListener('change', (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (event) => { const img = new Image(); img.onload = () => { state.image = img; document.getElementById('previewThumb').src = img.src; document.getElementById('previewThumb').classList.remove('hidden'); window.resetImageTransform(); renderUI(); drawCanvas(); }; img.src = event.target.result; }; reader.readAsDataURL(file); } });
        document.getElementById('btnSafeZone').addEventListener('click', () => { state.showSafeZone = !state.showSafeZone; renderUI(); drawCanvas(); });
        
        document.getElementById('btnAddText').addEventListener('click', () => {
            const newId = Date.now();
            state.texts.push(createTextObject(newId, "NEW TEXT", 360));
            state.activeTextId = newId;
            renderUI(); drawCanvas();
        });
        document.getElementById('btnDeleteText').addEventListener('click', () => {
            if(state.texts.length > 1) {
                state.texts = state.texts.filter(t => t.id !== state.activeTextId);
                state.activeTextId = state.texts[0].id;
                renderUI(); drawCanvas();
            } else { alert("You must have at least one text layer!"); }
        });

        document.getElementById('textContent').addEventListener('input', (e) => { updateActiveText('content', e.target.value); });
        document.getElementById('colorPicker').addEventListener('input', (e) => { updateActiveText('color', e.target.value); });
        document.getElementById('fontSize').addEventListener('input', (e) => { updateActiveText('fontSize', e.target.value); });
        document.getElementById('strokeWidth').addEventListener('input', (e) => { updateActiveText('strokeWidth', e.target.value); });
        
        document.getElementById('gradientToggle').addEventListener('change', (e) => { const t = getActiveText(); t.gradient.enabled = e.target.checked; renderUI(); drawCanvas(); });
        document.getElementById('gradStartColor').addEventListener('input', (e) => { const t = getActiveText(); t.gradient.start = e.target.value; renderUI(); drawCanvas(); });
        document.getElementById('gradEndColor').addEventListener('input', (e) => { const t = getActiveText(); t.gradient.end = e.target.value; renderUI(); drawCanvas(); });
        
        document.getElementById('shadowToggle').addEventListener('change', (e) => { const t = getActiveText(); t.shadow.enabled = e.target.checked; renderUI(); drawCanvas(); });
        document.getElementById('shadowColorPicker').addEventListener('input', (e) => { const t = getActiveText(); t.shadow.color = e.target.value; renderUI(); drawCanvas(); });
        document.getElementById('shadowBlur').addEventListener('input', (e) => { const t = getActiveText(); t.shadow.blur = e.target.value; renderUI(); drawCanvas(); });
        document.getElementById('shadowDistance').addEventListener('input', (e) => { const t = getActiveText(); t.shadow.distance = e.target.value; renderUI(); drawCanvas(); });

        document.getElementById('filterBrightness').addEventListener('input', (e) => { state.filters.brightness = e.target.value; drawCanvas(); });
        document.getElementById('filterContrast').addEventListener('input', (e) => { state.filters.contrast = e.target.value; drawCanvas(); });
        document.getElementById('filterSaturate').addEventListener('input', (e) => { state.filters.saturate = e.target.value; drawCanvas(); });
        document.getElementById('imageZoom').addEventListener('input', (e) => { state.bgTransform.scale = parseFloat(e.target.value); drawCanvas(); });
        document.getElementById('borderToggle').addEventListener('change', (e) => { state.border.enabled = e.target.checked; renderUI(); drawCanvas(); });
        document.getElementById('borderColorPicker').addEventListener('input', (e) => { state.border.color = e.target.value; drawCanvas(); });
        document.getElementById('borderThickness').addEventListener('input', (e) => { state.border.width = e.target.value; drawCanvas(); });

        document.getElementById('stickerScale').addEventListener('input', (e) => { const s = state.stickers.find(x => x.id === state.selectedStickerId); if (s) { s.scale = e.target.value; drawCanvas(); } });
        document.getElementById('stickerRotation').addEventListener('input', (e) => { const s = state.stickers.find(x => x.id === state.selectedStickerId); if (s) { s.rotation = e.target.value; drawCanvas(); } });
        document.getElementById('btnDeleteSticker').addEventListener('click', () => { state.stickers = state.stickers.filter(s => s.id !== state.selectedStickerId); state.selectedStickerId = null; renderUI(); drawCanvas(); });
        document.getElementById('btnFlipSticker').addEventListener('click', () => { const s = state.stickers.find(x => x.id === state.selectedStickerId); if (s) { s.scaleX = s.scaleX * -1; drawCanvas(); } });

        document.getElementById('btnMagicRemix').addEventListener('click', () => {
            const t = getActiveText();
            t.fontFamily = FONTS[Math.floor(Math.random() * FONTS.length)].value; 
            t.color = COLORS[Math.floor(Math.random() * COLORS.length)]; 
            t.strokeWidth = Math.floor(Math.random() * 20) + 10;
            renderUI(); drawCanvas();
        });
        document.getElementById('btnResetApp').addEventListener('click', resetApp);
        btnDownload.addEventListener('click', async () => { if (!state.image) return; const wasSafeZoneOn = state.showSafeZone; if (wasSafeZoneOn) { state.showSafeZone = false; state.activeTextId = null; drawCanvas(); } const btn = document.getElementById('btnDownload'); const originalText = btn.innerHTML; btn.innerHTML = `SAVING...`; const getBlob = (quality, type) => new Promise(resolve => canvas.toBlob(resolve, type, quality)); let blob = await getBlob(1, 'image/png'); let extension = 'png'; if (blob.size > 2 * 1024 * 1024) { extension = 'jpg'; let quality = 0.95; while (quality > 0.1) { blob = await getBlob(quality, 'image/jpeg'); if (blob.size < 2000000) break; quality -= 0.1; } } const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.download = `tubethumb-${Date.now()}.${extension}`; link.href = url; link.click(); URL.revokeObjectURL(url); document.getElementById('downloadStatus').classList.remove('opacity-0'); setTimeout(() => { btn.innerHTML = originalText; document.getElementById('downloadStatus').classList.add('opacity-0'); }, 3000); if (wasSafeZoneOn) { state.showSafeZone = true; drawCanvas(); } });

        const getCanvasCoords = (e) => { const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; let clientX = e.touches ? e.touches[0].clientX : e.clientX; let clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY }; };

        const handleStart = (e) => {
            e.preventDefault(); const coords = getCanvasCoords(e); let hitFound = false;
            for (let i = state.stickers.length - 1; i >= 0; i--) {
                const s = state.stickers[i]; const dist = Math.hypot(s.x - coords.x, s.y - coords.y); const hitRadius = s.type === 'emoji' ? 60 * s.scale : 100 * s.scale;
                if (dist < hitRadius) { state.selectedStickerId = s.id; state.isDragging = true; state.dragOffset = { x: coords.x - s.x, y: coords.y - s.y }; hitFound = true; break; }
            }
            if (!hitFound) {
                for (let i = state.texts.length - 1; i >= 0; i--) {
                    const text = state.texts[i];
                    const metrics = getTextMetrics(text.content, text.fontFamily, text.fontSize);
                    const halfW = metrics.width / 2 + 20; const halfH = metrics.height / 2 + 20;
                    if (coords.x >= text.x - halfW && coords.x <= text.x + halfW && coords.y >= text.y - halfH && coords.y <= text.y + halfH) {
                        state.activeTextId = text.id; 
                        state.isDraggingText = true; state.dragTextId = text.id;
                        state.dragOffset = { x: coords.x - text.x, y: coords.y - text.y };
                        state.selectedStickerId = null; hitFound = true; 
                        renderUI(); 
                        break;
                    }
                }
            }
            if (!hitFound && state.image) { state.isDraggingBg = true; state.dragOffset = { x: coords.x - state.bgTransform.x, y: coords.y - state.bgTransform.y }; state.selectedStickerId = null; }
            if (!hitFound && !state.isDraggingBg) { state.selectedStickerId = null; }
            drawCanvas();
        };

        const handleMove = (e) => {
            e.preventDefault(); const coords = getCanvasCoords(e);
            if (state.isDragging && state.selectedStickerId) { const s = state.stickers.find(x => x.id === state.selectedStickerId); if (s) { s.x = coords.x - state.dragOffset.x; s.y = coords.y - state.dragOffset.y; drawCanvas(); } } 
            else if (state.isDraggingText && state.dragTextId) { 
                const t = state.texts.find(x => x.id === state.dragTextId);
                if (t) { t.x = coords.x - state.dragOffset.x; t.y = coords.y - state.dragOffset.y; drawCanvas(); }
            }
            else if (state.isDraggingBg) { state.bgTransform.x = coords.x - state.dragOffset.x; state.bgTransform.y = coords.y - state.dragOffset.y; drawCanvas(); }
        };

        const handleEnd = () => { state.isDragging = false; state.isDraggingText = false; state.isDraggingBg = false; state.dragTextId = null; };
        const handleWheel = (e) => { e.preventDefault(); if (state.image) { const delta = e.deltaY > 0 ? -0.1 : 0.1; let newScale = state.bgTransform.scale + delta; newScale = Math.min(Math.max(0.1, newScale), 5); state.bgTransform.scale = newScale; renderUI(); drawCanvas(); } };

        canvas.addEventListener('mousedown', handleStart); canvas.addEventListener('mousemove', handleMove); canvas.addEventListener('mouseup', handleEnd); canvas.addEventListener('mouseleave', handleEnd);
        canvas.addEventListener('touchstart', handleStart); canvas.addEventListener('touchmove', handleMove); canvas.addEventListener('touchend', handleEnd); canvas.addEventListener('wheel', handleWheel);
    }
    document.fonts.ready.then(init);
</script>
</body>
</html>